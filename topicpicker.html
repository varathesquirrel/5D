<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>5D Topic Picker</title>
 <link rel="icon" href="https://cdn-icons-png.flaticon.com/512/5052/5052297.png" type="image/x-icon">
 <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>

<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="topicpickerstyles.css">
</head>

<body>

<!-- MAIN SECTION -->
<div class="main">

    <!-- Floating Collapse Button -->
<button id="collapseHistoryBtn">
    <svg id="collapseIcon" width="22" height="22" viewBox="0 0 24 24" fill="currentColor">
        <!-- Arrow pointing LEFT (expand) -->
        <path d="M15 6l-6 6 6 6"/>
    </svg>
</button>


    <div class="controls">
        <button onclick="pickTopic()">Pick Topic</button>
		<button id="settingsBtn">‚öôÔ∏è</button>
        <span id="timerDisplay" style="margin-left:auto; font-size:20px;">00:00</span>
    </div>
<div id="mainContainer">
    <!-- Wheel + button -->
    <div id="wheelContainer">
        <div id="wheelPointer"></div>
        <canvas id="wheelCanvas" width="400" height="400"></canvas>
        <button id="spinButton">SPIN</button>
    </div>

    <!-- Topic card -->
    <div id="topicCardContainer">
        <div class="topicCard" id="cardA">Click on "Pick Topic" <br>OR<br> Spin the Wheel üé≤</div>
        <div class="topicCard" id="cardB">Click on "Pick Topic" <br>OR<br> Spin the Wheel üé≤</div>
    </div>
</div>

	<div id="paragraph">
	</div>
</div>
<audio id="spinSound" src="tick.mp3" preload="auto"></audio>
<audio id="flapperSound" src="flap.mp3" preload="auto"></audio>
<audio id="cheerSound" src="cheer.mp3" preload="auto"></audio>


<!-- HISTORY PANEL -->
<div class="history-panel history-collapsed">
    <h2>History</h2>
    <div id="historyList"></div>
</div>

<div id="settingsModal" class="modal">
    <div class="modal-content">
        <span class="closeBtn">&times;</span>
        <div id="settingsPanel">
            <label><input type="checkbox" id="darkModeToggle" checked> Dark Mode</label><br>
            <label><input type="checkbox" id="noRepeatToggle" checked> Do Not Repeat Topics</label><br>
            <div>
                Timer:
                <input type="number" id="timerMinutes" value="3" min="0" style="width:60px;"> min
                <input type="number" id="timerSeconds" value="0" min="0" max="59" style="width:60px;"> sec
            </div>
					<div><br>
    <label>
        <input type="checkbox" id="bigBookLineToggle"> Random Big Book Line
    </label></div><div><br>
    <label><input type="checkbox" id="showParagraphBtn" checked>Show full paragraph</label>
</div>
        </div>
    </div>
</div>

<!-- Topics Array -->
<script src="topics.js"></script>
<script src="bigBookLines.js"></script>
<script src="bigBookParagraphs.js"></script>
<script src="wheel.js"></script>
<script>
    let usedTopics = new Set();
    let timerInterval = null;

    // Collapse history by default
    const historyPanel = document.querySelector(".history-panel");
    const collapseBtn = document.getElementById("collapseHistoryBtn");
    const collapseIcon = document.getElementById("collapseIcon");

    // Collapse / Expand Logic
    collapseBtn.onclick = () => {
        if (historyPanel.classList.contains("history-collapsed")) {
            historyPanel.classList.remove("history-collapsed");
            collapseIcon.style.transform = "scale(-1,1)"; // arrow right
        } else {
            historyPanel.classList.add("history-collapsed");
            collapseIcon.style.transform = "scale(1,1)"; // arrow left
        }
    };


    // Dark Mode
	document.body.classList.toggle("dark", this.checked);
    document.getElementById("darkModeToggle").onchange = function() {
        document.body.classList.toggle("dark", this.checked);
    };
const cardColors = [
    ["#4facfe", "#00f2fe"],
    ["#43e97b", "#38f9d7"],
    ["#fa709a", "#fee140"],
    ["#30cfd0", "#330867"],
    ["#a18cd1", "#fbc2eb"],
    ["#f6d365", "#fda085"],
    ["#5ee7df", "#b490ca"]
];
function fitTopicCard(card) {
    const title = card.querySelector(".topic-title");
    const subtitle = card.querySelector(".topic-subtitle");

    if (!title || !subtitle) return;

    let titleFont = 80;   // starting font size for title
    let subtitleFont = 42; // starting font size for subtitle

    // Set initial font sizes
    title.style.fontSize = titleFont + "px";
    subtitle.style.fontSize = subtitleFont + "px";

    // Compute max available height
    const maxHeight = card.clientHeight - 20; // leave some padding
    const maxWidth = card.clientWidth - 20;

    // Shrink title/subtitle until both fit
    while ((title.scrollHeight + subtitle.scrollHeight > maxHeight || 
            title.scrollWidth > maxWidth || subtitle.scrollWidth > maxWidth) && titleFont > 12) {
        titleFont -= 1;
        subtitleFont = Math.max(subtitleFont - 0.5, 10); // shrink subtitle proportionally
        title.style.fontSize = titleFont + "px";
        subtitle.style.fontSize = subtitleFont + "px";
    }
}


function randomCardGradient() {
    const pair = cardColors[Math.floor(Math.random() * cardColors.length)];
    return `linear-gradient(135deg, ${pair[0]}, ${pair[1]})`;
}
let showingCardA = true;

function renderTopicIntoCard(card, topic) {
    card.style.background = randomCardGradient();
    card.innerHTML = `
        <div class="topic-content">
            <div class="topic-title">${topic.title||topic.line}</div>
            <div class="topic-subtitle">${topic.subtitle || topic.page ||""}</div>
        </div>
    `;
	fitTopicCard(card);
}
function pickTopicOld(){
        if (!topics || topics.length === 0) {
            alert("No topics loaded!");
            return;
        }

        let available = topics;

        if (document.getElementById("noRepeatToggle").checked) {
            available = topics.filter(t => !usedTopics.has(t.title));
            if (available.length === 0) {
                alert("All topics used!");
                return;
            }
        }

        const chosen = available[Math.floor(Math.random() * available.length)];
		

        usedTopics.add(chosen.title);
        addToHistory(chosen.title);
		pickTopicFinal(chosen);
}

    // Pick Topic
    function pickTopicFinal(chosen) {

const cardA = document.getElementById("cardA");
const cardB = document.getElementById("cardB");

const incoming = showingCardA ? cardB : cardA;
const outgoing = showingCardA ? cardA : cardB;

// Render topic into incoming card
renderTopicIntoCard(incoming, chosen);

// Reset animation class so it can replay
incoming.classList.remove("slide-in-from-bottom");
void incoming.offsetWidth; // force reflow

// Bring incoming card on top
incoming.style.zIndex = 2;
outgoing.style.zIndex = 1;

// Animate
incoming.classList.add("slide-in-from-bottom");

// After animation ends, swap roles
setTimeout(() => {
    outgoing.style.zIndex = 1;
    incoming.style.zIndex = 2;
    showingCardA = !showingCardA;
}, 450);



        startTimer();
    }

    function addToHistory(text) {
        const list = document.getElementById("historyList");
        const div = document.createElement("div");
        div.textContent = text;
        list.prepend(div);
    }

    // Timer
    function startTimer() {
        const min = parseInt(document.getElementById("timerMinutes").value);
        const sec = parseInt(document.getElementById("timerSeconds").value);

        let total = min * 60 + sec;
        const display = document.getElementById("timerDisplay");

        if (timerInterval) clearInterval(timerInterval);

        function update() {
            const m = String(Math.floor(total / 60)).padStart(2, "0");
            const s = String(total % 60).padStart(2, "0");
            display.textContent = `${m}:${s}`;

            if (total <= 0) {
                clearInterval(timerInterval);
                return;
            }
            total--;
        }

        update();
        timerInterval = setInterval(update, 1000);
    }
	

let lastPickedParagraphId = null;
let lastPickedLine=null;
let highlighted=null;
        document.getElementById("showParagraphBtn").style.display = 'inline-block';


document.getElementById("showParagraphBtn").onchange = function() {
if(!document.getElementById("showParagraphBtn").checked)
{document.getElementById("paragraph").innerHTML="";
return;}
    if (!lastPickedParagraphId) return;
    const para = validParagraphs.find(p => p.paragraphId === lastPickedParagraphId);
    if (para)	document.getElementById("paragraph").innerHTML=`${highlighted}<pre>${para.chapter||""}pp. ${para.page||""}</pre>`;
};
const validParagraphs = bigBookParagraphs.filter(p => p.chapter && p.page);
function pickTopic() {
    if (document.getElementById("bigBookLineToggle").checked) {
        let chosen = bigBookLines[Math.floor(Math.random() * bigBookLines.length)];
		let para = validParagraphs.find(p => p.paragraphId === chosen.paragraphId);
		while(!para)
		{
		chosen = bigBookLines[Math.floor(Math.random() * bigBookLines.length)];
		para = validParagraphs.find(p => p.paragraphId === chosen.paragraphId);
		}
		

        pickTopicFinal(chosen);

        lastPickedParagraphId = chosen.paragraphId;
		lastPickedLine=chosen.line;
		

	// Escape regex special chars in line
    const escapedLine = lastPickedLine.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

    // Replace first occurrence of the line with bolded version
    highlighted = para.text.replace(
        new RegExp(escapedLine),
        `<strong>${lastPickedLine}</strong>`
    );
if(document.getElementById("showParagraphBtn").checked){
	document.getElementById("paragraph").innerHTML=`${highlighted}<pre>${para.chapter||""} (pp. ${para.page||""})</pre>`;
	}
        return;
    }

    // Existing topic picker logic...
	pickTopicOld();
}

function revealTopic(topic) {
  pickTopic();
}

function revealSpecial(type) {
    const messages = {
        "ü™ô": "ü™ô Get a 5D Coin!",
        "üë•": "üë• Talk to Mike P. for 30 min",
        "üí∞": "Get a Free Big Book!"
    };
	topic={
	"title":`${messages[type]}`
	}
	pickTopicFinal(topic);
	revealSpecialCheer();
}
function revealSpecialCheer() {
    // Play cheer
    const cheer = document.getElementById("cheerSound");
    cheer.currentTime = 0;
    cheer.play();


    // Trigger confetti
    launchConfetti();
}
function launchConfetti() {
    const duration = 3 * 1000; // 3 seconds
    const animationEnd = Date.now() + duration;
    const colors = ['#ffce00', '#ff5733', '#0099ff', '#33ff77', '#ff33aa', '#33ffff'];

    (function frame() {
        const timeLeft = animationEnd - Date.now();

        // Increase particle count as time goes on
        const particleCount = 50 * (timeLeft / duration);

        confetti({
            particleCount: Math.floor(particleCount),
            angle: Math.random() * 360, // random directions
            spread: 360,
            origin: { x: Math.random(), y: Math.random() }, // anywhere on screen
            colors: colors,
            scalar: 1.2, // slightly bigger particles
            drift: Math.random() * 5 - 2.5, // horizontal drift
            gravity: 0.6
        });

        if (timeLeft > 0) {
            requestAnimationFrame(frame);
        }
    })();
}

window.addEventListener("keydown", (e) => {
    if (e.key === "Escape") modal.style.display = "none";
});


const settingsBtn = document.getElementById("settingsBtn");
const modal = document.getElementById("settingsModal");
const closeBtn = modal.querySelector(".closeBtn");

// Open modal
settingsBtn.addEventListener("click", () => {
  modal.style.display = "flex"; // must use flex for centering
});

// Close modal
closeBtn.addEventListener("click", () => {
  modal.style.display = "none";
});

// Close when clicking outside content
window.addEventListener("click", (e) => {
  if (e.target === modal) {
    modal.style.display = "none";
  }
});
modal.style.display = "none";


</script>

</body>
</html>
